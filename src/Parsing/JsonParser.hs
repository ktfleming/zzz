{-# LANGUAGE OverloadedStrings #-}

module Parsing.JsonParser
  ( parseLine,
    JsonLine (..),
    Indentation (..),
    EndingComma (..),
    JsonKey (..),
    JsonValue (..),
  )
where

import qualified Data.Text as T
import Data.Text (Text)
import Data.Void (Void)
import Text.Megaparsec
  ( (<|>),
    Parsec,
    choice,
    eof,
    manyTill,
    some,
    takeWhileP,
    try,
  )
import Text.Megaparsec.Char
  ( char,
    digitChar,
    string,
  )
import qualified Text.Megaparsec.Char.Lexer as L

-- This module contains a simple customer parser to help with colorizing JSON output.
-- This parser will only be run on text that's already been run through aeson-pretty,  so we can just
-- parse one line at a time, and we know that each line should be one of a limited number of patterns.

-- This is the key on the left side of a ':', needs to be a literal string.
newtype JsonKey = JsonKey Text deriving (Show)

-- Values that can show up on the right side of a ':'
data JsonValue
  = JsonStringValue Text
  | JsonNumber Text
  | JsonBool Bool
  | JsonNull
  deriving (Show)

-- We need to preserve the whitespace generated by aeson-pretty, so it gets stored in this newtype.
newtype Indentation = Indentation Text deriving (Show)

-- Most lines can optionally end with a comma
newtype EndingComma = EndingComma Bool deriving (Show)

-- Each line output by aeson-pretty should fall into one of these patterns.
data JsonLine
  = JustLCB Indentation -- {
  | JustLSB Indentation -- [
  | ObjectStart Indentation JsonKey -- "something": {
  | KeyValue Indentation JsonKey JsonValue EndingComma -- "something": "value", "something": true, etc with optional ending comma
  | EmptyArray Indentation JsonKey EndingComma -- "something" : []
  | EmptyObject Indentation JsonKey EndingComma -- "something": {}
  | ArrayStart Indentation JsonKey -- "something" : [
  | ValueInArray Indentation JsonValue EndingComma -- "value"
  | JustRCB Indentation EndingComma -- } or },
  | JustRSB Indentation EndingComma -- ] or ],
  deriving (Show)

type JsonParser = Parsec Void Text

-- Main parsing function; just find which JsonLine pattern the provided text matches.
parseLine :: JsonParser JsonLine
parseLine =
  choice $
    try
      <$> [ justLCB,
            justLSB,
            objectStart,
            keyValue,
            emptyArray,
            emptyObject,
            arrayStart,
            valueInArray,
            justRCB,
            justRSB
          ]

-- Individual parsers for each JsonLine pattern:

justLCB :: JsonParser JsonLine
justLCB = JustLCB <$> indentation <* char '{' <* eof

justLSB :: JsonParser JsonLine
justLSB = JustLSB <$> indentation <* char '[' <* eof

objectStart :: JsonParser JsonLine
objectStart = ObjectStart <$> indentation <*> key <* string ": {" <* eof

keyValue :: JsonParser JsonLine
keyValue = KeyValue <$> indentation <*> key <* string ": " <*> value <*> endingComma

emptyArray :: JsonParser JsonLine
emptyArray = EmptyArray <$> indentation <*> key <* string ": []" <*> endingComma

emptyObject :: JsonParser JsonLine
emptyObject = EmptyObject <$> indentation <*> key <* string ": {}" <*> endingComma

arrayStart :: JsonParser JsonLine
arrayStart = ArrayStart <$> indentation <*> key <* string ": [" <* eof

valueInArray :: JsonParser JsonLine
valueInArray = ValueInArray <$> indentation <*> value <*> endingComma

justRCB :: JsonParser JsonLine
justRCB = JustRCB <$> indentation <* char '}' <*> endingComma

justRSB :: JsonParser JsonLine
justRSB = JustRSB <$> indentation <* char ']' <*> endingComma

-- Helper parsers for elements that can appear in JsonLine:

indentation :: JsonParser Indentation
indentation = Indentation <$> takeWhileP Nothing (== ' ')

endingComma :: JsonParser EndingComma
endingComma = try yes <|> no
  where
    yes = EndingComma True <$ char ',' <* eof
    no = EndingComma False <$ eof

stringLiteral :: JsonParser String
stringLiteral = char '\"' *> manyTill L.charLiteral (char '\"')

key :: JsonParser JsonKey
key = JsonKey . T.pack <$> stringLiteral

value :: JsonParser JsonValue
value =
  choice
    [ JsonNull <$ string "null",
      JsonBool True <$ string "true",
      JsonBool False <$ string "false",
      -- this one is pretty hacky (it would accept input like "+EE+2"), but I'm relying on text making it through
      -- Aeson's decode function, so for now I'm going to assume only "real" JSON numbers will make it to this function.
      JsonNumber . T.pack <$> some (choice [digitChar, char '.', char 'E', char '+']),
      JsonStringValue . T.pack <$> stringLiteral
    ]
